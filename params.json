{"name":"jorm-unit","tagline":"JUnit extension to assist out-of-server automated JPA testing","body":"## Iterate fast while testing, debugging and studying JPA implementations.\r\njorm-unit assists running tests  out-of-server for JPA (Java Persistence API) code. The list of features is: \r\n\r\n- Reuse of `EntityManagerFactory`through all tests in order to speed up execution\r\n- Automatic transaction management\r\n- Loading of test data before test execution using [DBUnit](http://http://dbunit.sourceforge.net/) XML datasets\r\n- Comparison of database state after test against [DBUnit](http://http://dbunit.sourceforge.net/) XML datasets\r\n- Printing of database state at any point during the test\r\n\r\n## Usage\r\n\r\n```java\r\npublic class SampleTest extends JPATest {\r\n\r\n\t@Test\r\n\t@Transactional\r\n\t@BeforeDataSet(fileName = \"initialTestData.xml\")\r\n\t@AfterDataSet(fileName = \"expectedTestData.xml\")\r\n\t@PrintDatabase\r\n\tpublic void testSaveDataAutomaticTransaction() {\r\n\t\tCustomer cust = new Customer(\"Customer 2\");\r\n\t\tgetEntityManager().persist(cust);\r\n\r\n\t\tAssert.assertNotNull(cust.getId());\r\n\t}\r\n\r\n}\r\n```\r\n```\r\nOutput:\r\n\r\nCUSTOMER [2 rows]\r\n________________\r\n| ID| NAME      |\r\n|===============|\r\n| -1| Customer 1|\r\n| 1 | Customer 2|\r\n```\r\n\r\n## Getting started\r\n\r\nYou can jump start using the the Maven `jorm-unit-sample-archetype` or adding jorm-unit to your existing project\r\n\r\n#####Maven archetype\r\n\r\n```\r\nmvn archetype:generate -DarchetypeArtifactId=jorm-unit-sample-archetype -DarchetypeGroupId=org.jorm-unit -DarchetypeVersion=1.0.1\r\n```\r\n\r\nInform `hibernate` or `eclipselink` for the `jpa-provider` property. The generated POM will be setup accordingly\r\n\r\n```\r\n[INFO] Scanning for projects...\r\n[INFO]                                                                         \r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building Maven Stub Project (No POM) 1\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] \r\n[INFO] >>> maven-archetype-plugin:2.2:generate (default-cli) @ standalone-pom >>>\r\n[INFO] \r\n[INFO] <<< maven-archetype-plugin:2.2:generate (default-cli) @ standalone-pom <<<\r\n[INFO] \r\n[INFO] --- maven-archetype-plugin:2.2:generate (default-cli) @ standalone-pom ---\r\n[INFO] Generating project in Interactive mode\r\nDefine value for property 'groupId': : mycomp\r\nDefine value for property 'artifactId': : myjpatest\r\nDefine value for property 'version':  1.0-SNAPSHOT: : \r\nDefine value for property 'package':  mycomp: : com.mycomp\r\nDefine value for property 'jpa-provider': : hibernate\r\n```\r\n#####Adding jorm-unit to your existing project\r\n\r\n```xml\r\n <dependency>\r\n   \t<groupId>org.jorm-unit</groupId>\r\n    \t<artifactId>jorm-unit</artifactId>\r\n     \t<version>1.0.0</version>\r\n     \t<exclusions>\r\n     \t    <exclusion>\r\n      \t\t\t<groupId>org.eclipse.persistence</groupId>\r\n      \t\t\t<artifactId>javax.persistence</artifactId>\r\n   \t\t\t</exclusion>     \t\t\r\n     \t</exclusions>\r\n     \t<scope>test</scope>\r\n </dependency>\r\n```\r\n## Going forward\r\n\r\n#####Settting up persistence unit\r\n\r\nBy default jorm-unit will try to use a persistence unit named `default-pu`. To specify one persistence unit annotate your test class with `TestConfiguration`\r\n\r\n```java\r\n@TestConfiguration(persistenceUnitName=\"simple-pu\")\r\npublic class SampleTest extends JPATest\r\n```\r\n\r\n#####Setting up tests for Hibernate\r\n\r\nif you make use of `AfterDataSet`, `BeforeDataSet` or print database state features jorm-unit needs direct access to your database. Since JPA 2.0 providers give acess to the wrapped JDBC connection with the method `EntityManager.unwrap`. \r\n\r\nApparently this method does not work with Hibernate running without JTA transactions. For this scenario your test class must provide the current JDBC connection. It can be achieved in two ways. \r\n\r\na) Overriding the method  `getCurrentDatabaseConnection`\r\n\r\n```java\r\npublic class SampleTest extends JPATest {\r\n\t@Override\r\n\tprotected Connection getCurrentDatabaseConnection() {\r\n\t\treturn ((SessionImpl) getEntityManager().getDelegate()).connection();\r\n\t}\r\n}\r\n```\r\nb) Implementing the interface `DatabaseConnectionProvider`\r\n\r\n```java\r\n@TestConfiguration(persistenceUnitName=\"simple-pu\", connectionProvider=SampleTest.HibernateConnectionProvider.class)\r\npublic class SampleTest extends JPATest {\r\n\r\n\tpublic static class HibernateConnectionProvider implements DatabaseConnectionProvider {\r\n\r\n\t\t@Override\r\n\t\tpublic Connection getCurrentConnection(EntityManager em) {\r\n\t\t\treturn ((SessionImpl) em.getDelegate()).connection();\r\n\t\t}\r\n\t\t\r\n\t}\r\n}\r\n```\r\n\r\n>**Note**:  Providing the current JDBC connection is not necessary if you are using other JPA implementation such as EclipseLink or is not using DBUnit's XML datasets and database state printing features\r\n\r\n#####Choosing the transaction management strategy\r\n\r\nYou may annotate your test methods with `Transactional`and jorm-unit will open a transaction before each test and complete it after the test ends. If the test finished without exceptions the transaction is committed otherwise it is rolled back.\r\n\r\nIt is also possible to demarcate transaction boundaries manually using the current `EntityManager`\r\n\r\n```java\r\npublic class SampleTest extends JPATest {\r\n\r\n\t@Test\r\n\t@Transactional\r\n\tpublic void testSaveDataAutomaticTransaction() {\r\n\t\tCustomer cust = new Customer(\"Customer 2\");\r\n\t\tgetEntityManager().persist(cust);\r\n\r\n\t\tAssert.assertNotNull(cust.getId());\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testSaveDataNonAutomaticTransaction() {\r\n\t\tCustomer cust = new Customer(\"Customer 2\");\r\n\r\n         \ttry {\r\n\t\t\tgetEntityManager().beginTransaction();\r\n\t\t\tgetEntityManager().persist(cust);\r\n\t\t\tgetEntityManager().commitTransaction();\r\n\t\t} catch (Exception e) {\r\n\t\t\tgetEntityManager().rollbackTransaction();\r\n\t\t\tthrow e;\r\n\t\t}\r\n\r\n\t\tAssert.assertNotNull(cust.getId());\r\n\t}\r\n}\r\n```\r\n\r\n#####Printing the database state\r\n\r\nThe rows of every table in the database can be printed to console by the end of every test using the annotation `PrintDatabase`\r\n\r\n```java\r\npublic class SampleTest extends JPATest {\r\n\r\n\t@Test\r\n\t@Transactional\r\n \t@PrintDatabase\r\n\tpublic void testSaveDataAutomaticTransaction() {\r\n\t\tCustomer cust = new Customer(\"Customer 2\");\r\n\t\tgetEntityManager().persist(cust);\r\n\r\n\t\tAssert.assertNotNull(cust.getId());\r\n\t}\r\n}\r\n```\r\nOutput:\r\n\r\n```\r\nCUSTOMER [2 rows]\r\n________________\r\n| ID| NAME      |\r\n|===============|\r\n| 1 | Customer 2|\r\n```\r\n\r\nIt is possible to print the database state at any moment of the test by invoking the method `printDatabase`\r\n\r\n```java\r\npublic class SampleTest extends JPATest {\r\n\r\n\t@Test\r\n\t@Transactional\r\n\tpublic void testSaveDataAutomaticTransaction() {\r\n                          \r\n\t\tprintDatabase();\r\n\t\tCustomer cust = new Customer(\"Customer 2\");\r\n\t\tgetEntityManager().persist(cust);\r\n\r\n\t\tAssert.assertNotNull(cust.getId());\r\n\t}\r\n}\r\n```\r\nOutput:\r\n\r\n```\r\nCUSTOMER is empty\r\n```\r\n\r\njorm-unit will introspect the database using the following ANSI SQL query\r\n\r\n```sql\r\nSELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'TABLE'\r\n```\r\n\r\nIn case your DBMS does not support INFORMATION_SCHEMA view (such as *Oracle*) you must implement the interface `DatabaseInstrospector`\r\n\r\n```java\r\npublic class OracleDatabaseInstrospector implements DatabaseInstrospector {\r\n\r\n\t@Override\r\n\tpublic String getAllTablesSqlQuery() {\r\n\t\treturn \"SELECT table_name FROM user_tables\";\r\n\t}\r\n\r\n}\r\n\r\n@TestConfiguration(persistenceUnitName=\"simple-pu\", databaseInstrospector=OracleDatabaseInstrospector.class)\r\npublic class SampleTest extends JPATest {\r\n\r\n\t@Test\r\n\t@Transactional\r\n\tpublic void testSaveDataAutomaticTransaction() {\r\n                          \r\n\t\tprintDatabase();\r\n\t\tCustomer cust = new Customer(\"Customer 2\");\r\n\t\tgetEntityManager().persist(cust);\r\n\r\n\t\tAssert.assertNotNull(cust.getId());\r\n\t}\r\n}\r\n\r\n```\r\n\r\n#####Loading test data\r\n\r\nTo run tests against a well known data set it is possible to load a [DBUnit flat XML data set](http://dbunit.sourceforge.net/apidocs/org/dbunit/dataset/xml/FlatXmlDataSet.html) prior to each test execution\r\n\r\n*testdata.xml*\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<dataset>\r\n\t<customer id=\"-1\" name=\"Customer 1\" />\r\n\t<orderoption />\r\n\t<salesorder />\r\n\t<orderitem />\r\n\t<order_option_selection />\r\n</dataset>\r\n```\r\n\r\n*testdata.xml* must be in the class path, for example at `src/test/resources` if default Maven project layout is adopted. \r\n\r\n>**Important** : The tag names and attributes refer to actual database tables and columns and not Java classes and attributes\r\n\r\n```java\r\npublic class SampleTest extends JPATest {\r\n\r\n\t@Test\r\n\t@Transactional\r\n \t@BeforeDataSet(fileName = \"testdata.xml\")\r\n\tpublic void testFetchCustomer() {\r\n\t\tprintDatabase();\r\n\t\tCustomer cust = getEntityManager().find(Customer.class, new Long(-1));\r\n\t\tAssert.assertNotNull(cust);\r\n\t\tAssert.assertEquals(\"Customer 1\", cust.getName());\r\n\t}\r\n}\r\n```\r\nOutput:\r\n\r\n```\r\nCUSTOMER [2 rows]\r\n________________\r\n| ID| NAME      |\r\n|===============|\r\n| -1 |Customer 1|\r\n```\r\n\r\njorm-unit will initially delete all rows of all tables mentioned in the XML file and then insert the records listed in the order it appears in the file\r\n\r\n#####Comparing database state to XML datasets\r\n\r\nAfter the execution of each test it is possible to compare the database state with a [DBUnit flat XML data set](http://dbunit.sourceforge.net/apidocs/org/dbunit/dataset/xml/FlatXmlDataSet.html). \r\n\r\n *expectedData.xml*\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<dataset>\r\n\t<customer name=\"Customer 2\" />\r\n\t<orderoption />\r\n\t<salesorder />\r\n\t<orderitem />\r\n\t<order_option_selection />\r\n</dataset>\r\n```\r\n*expectedData.xml* must be in the class path, for example at `src/test/resources` if default Maven  project layout is adopted.\r\n\r\n>**Important** : The tag names and attributes refer to actual database tables and columns and not Java classes and attributes\r\n\r\n```java\r\n@Test\r\n@Transactional\r\n@AfterDataSet(fileName = \"expectedData.xml\")\r\npublic void testSaveCustomer() throws Exception {\r\n\tCustomer cust = new Customer(\"Customer 2\");\r\n\tgetEntityManager().persist(cust);\r\n}\r\n```\r\n\r\nAfter the test execution it will be asserted that the table `CUSTOMER` has one row as listed and all other tables mentioned on the XML file with empty tags  have no rows.\r\n\r\n> **Important**: When composing data sets with expected data don't include columns with system generated values such as identity columns, sequence obtained values, time stamps and similar.\r\n\r\nNULL values can be referred on XML datasets using the constant `[NULL]`\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<dataset>\r\n\t<customer name=\"Customer 2\"  description=\"[NULL]\" />\r\n</dataset>\r\n```","google":"UA-54286751-1","note":"Don't delete this file! It's used internally to help with page regeneration."}